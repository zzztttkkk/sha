package middleware

import (
	"encoding/json"
	"fmt"
	"sync"
	"time"

	"github.com/go-redis/redis/v7"
	"github.com/rs/xid"
	"github.com/valyala/fasthttp"

	"github.com/zzztttkkk/snow/internal"
	"github.com/zzztttkkk/snow/middleware/interfaces"
	"github.com/zzztttkkk/snow/router"
	"github.com/zzztttkkk/snow/utils"
)

var (
	SessionInCookie = "session"
	SessionInHeader = "session"
	SessionExpire   = time.Hour
)

var sessionKeyPrefix = "snow"

type _SessionT struct {
	id    []byte
	valid bool
	key   string
}

func (s *_SessionT) String() string {
	return utils.B2s(s.id)
}

func (s *_SessionT) fromBytes(bytesV []byte) {
	if len(bytesV) != 20 {
		s.valid = false
		return
	}
	s.id = bytesV
	s.key = fmt.Sprintf("%s:session:%s", sessionKeyPrefix, s.String())
	s.valid = true
}

var sessionPool = sync.Pool{New: func() interface{} { return &_SessionT{id: make([]byte, 20, 20)} }}

func acquireSession() *_SessionT {
	return sessionPool.Get().(*_SessionT)
}

func releaseSession(s *_SessionT) {
	s.valid = false
	s.key = ""
	sessionPool.Put(s)
}

var redisClient redis.Cmdable

func (s *_SessionT) Set(key string, val interface{}) {
	bs, err := json.Marshal(val)
	if err != nil {
		panic(err)
	}
	if err = redisClient.HSet(s.key, key, bs).Err(); err != nil {
		panic(err)
	}
}

func (s *_SessionT) Get(key string, dst interface{}) bool {
	bs, err := redisClient.HGet(s.key, key).Bytes()
	if err != nil {
		if err == redis.Nil {
			return false
		}
		panic(err)
	}
	return json.Unmarshal(bs, dst) == nil
}

func (s *_SessionT) Del(keys ...string) {
	redisClient.HDel(s.key, keys...)
}

func makeUSidKey(uid int64) string {
	return fmt.Sprintf("sonw:sessionid:%d", uid)
}

type Auther interface {
	Auth(ctx *fasthttp.RequestCtx) interfaces.User
}

var auther Auther

const (
	sessionExistsFlagKey = "@."
)

func SessionAndAuthMiddleware(ctx *fasthttp.RequestCtx) {
	var session = acquireSession()
	defer releaseSession(session)

	var uid int64
	var sidKey string

	// session by uid
	user := auther.Auth(ctx)
	if user != nil {
		uid = user.GetId()
	}
	if uid > 0 {
		sidKey = makeUSidKey(uid)
		sid, _ := redisClient.Get(sidKey).Bytes()
		if len(sid) == 20 {
			session.fromBytes(sid)
			if session.valid {
				redisClient.Set(sidKey, sid, SessionExpire)
				var sUid int64
				if !session.Get("uid", &sUid) || sUid != uid {
					// delete dirty data
					redisClient.Del(session.key, sidKey)
					session.valid = false
				} else {
					ctx.SetUserValue(internal.RCtxKeyUser, user)
				}
			}
		}
	}

	// session by request
	if !session.valid {
		bytesV := ctx.Request.Header.Cookie(SessionInCookie)
		if len(bytesV) == 20 {
			session.fromBytes(bytesV)
		}

		if !session.valid {
			bytesV = ctx.Request.Header.Peek(SessionInHeader)
			if len(bytesV) == 20 {
				session.fromBytes(bytesV)
			}
		}
	}

	// check this sessionId is generated by our server
	if session.valid {
		var x bool
		if !session.Get(sessionExistsFlagKey, &x) {
			session.valid = false
		}
	}

	// generate new sessionId
	if !session.valid {
		session.fromBytes(utils.S2b(xid.New().String()))
		session.Set(sessionExistsFlagKey, true)
	}

	redisClient.Expire(session.key, SessionExpire)
	ctx.SetUserValue(internal.RCtxKeySession, session)

	ck := fasthttp.AcquireCookie()
	defer fasthttp.ReleaseCookie(ck)
	ck.SetKey(SessionInCookie)
	ck.SetValue(session.String())
	ck.SetPath("/")
	ck.SetMaxAge(int(SessionExpire / time.Second))
	ctx.Response.Header.SetCookie(ck)

	router.Next(ctx)
}
