package session

import (
	"context"
	"errors"
	"fmt"
	"github.com/go-redis/redis/v8"
	"github.com/zzztttkkk/sha/auth"
	"github.com/zzztttkkk/sha/captcha"
	"github.com/zzztttkkk/sha/jsonx"
	"github.com/zzztttkkk/sha/utils"
	"math/bits"
	"math/rand"
	"sync"
	"time"
)

type Options struct {
	Redis  utils.RedisConfig  `toml:"redis" json:"redis"`
	Auth   bool               `toml:"auth" json:"auth"`
	Prefix string             `json:"suffix" toml:"suffix"`
	MaxAge utils.TomlDuration `json:"max_age" toml:"max-age"`

	Captcha struct {
		MaxAge utils.TomlDuration `json:"max_age" toml:"max-age"`
		Skip   bool               `json:"skip" toml:"skip"`
	} `json:"captcha" toml:"captcha"`

	CSRF struct {
		CookieName string             `json:"cookie_name" toml:"cookie-name"`
		HeaderName string             `json:"header_name" toml:"header-name"`
		MaxAge     utils.TomlDuration `json:"max_age" toml:"max-age"`
		Skip       bool               `json:"skip" toml:"skip"`
	} `json:"csrf" toml:"csrf"`
}

var opts Options

func init() {
	utils.MathRandSeed()
}

var IDGenerator = func(v *[]byte) {
	const encodeStd = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	writeUint := func(q uint64) {
		var r uint64
		for {
			q, r = bits.Div64(0, q, 64)
			*v = append(*v, encodeStd[r])
			if q == 0 {
				break
			}
		}
	}
	writeUint(uint64(time.Now().UnixNano()))
	*v = append(*v, '.')
	for i := 0; i < 6; i++ {
		*v = append(*v, encodeStd[rand.Int()%64])
	}
}

var CRSFTokenGenerator = func(v []byte) {
	const encodeStd = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	for i := 0; i < len(v); i++ {
		v[i] = encodeStd[rand.Int()%64]
	}
}

var ImageCaptchaGenerator captcha.Generator
var AudioCaptchaGenerator captcha.Generator
var Marshal = jsonx.Marshal
var Unmarshal = jsonx.Unmarshal

var rcli redis.Cmdable
var once sync.Once
var DefaultOpts Options
var PrefixLength int
var maxage int64

func init() {
	DefaultOpts.Prefix = "session:"
	DefaultOpts.Redis.Mode = "singleton"
	DefaultOpts.MaxAge.Duration = time.Hour * 3
	DefaultOpts.Captcha.MaxAge.Duration = time.Minute * 5
	DefaultOpts.CSRF.CookieName = "csrf"
	DefaultOpts.CSRF.HeaderName = "X-CSRF"
	DefaultOpts.CSRF.MaxAge.Duration = time.Minute * 30
}

var (
	updateScriptHash   string
	clearScriptHash    string
	createScriptHash   string
	sessionsScriptHash string
)

func Init(opt *Options) {
	once.Do(func() {
		if opt == nil {
			opts = DefaultOpts
		} else {
			opts = *opt
			utils.Merge(&opts, DefaultOpts)
		}
		rcli = opts.Redis.Cli()
		PrefixLength = len(opt.Prefix)
		maxage = int64(opts.MaxAge.Duration / time.Second)

		var err error
		updateScriptHash, err = rcli.ScriptLoad(
			context.Background(),
			`
redis.call('hset', KEYS[1], KEYS[2], ARGV[1]);
redis.call('expire', KEYS[1], ARGV[2]);
return 1;
`,
		).Result()
		if err != nil {
			panic(err)
		}
		clearScriptHash, err = rcli.ScriptLoad(
			context.Background(),
			`
redis.call('del', KEYS[1]);
redis.call('hset', KEYS[1], '.created', redis.call('time')[1]);
return 1;
`,
		).Result()
		if err != nil {
			panic(err)
		}
		createScriptHash, err = rcli.ScriptLoad(
			context.Background(),
			`
redis.call('hset', KEYS[1], '.created', redis.call('time')[1]);
redis.call('expire', KEYS[1], ARGV[1]);
return 1;
`,
		).Result()
		if err != nil {
			panic(err)
		}
		sessionsScriptHash, err = rcli.ScriptLoad(
			context.Background(),
			`
local ret = {};
local sessions = redis.call('smembers', KEYS[1]);
if #sessions == 0 then
	return ret
end

for idx = 1, #sessions do
	local sid = sessions[idx];
	local ok = redis.call('exists', sessions[idx]);
	if ok then
		table.insert(ret, sid);
	else
		redis.call('srem', KEYS[1], sid);
	end
end

return ret;
`,
		).Result()
		if err != nil {
			panic(err)
		}
	})
}

var ErrEmptySession = errors.New("sha.session: nil")

func New(ctx context.Context, request Request) (s Session, err error) {
	var ptr = request.GetSessionID()
	if ptr == nil {
		return nil, ErrEmptySession
	}

	if *ptr == nil {
		*ptr = make([]byte, 0, 25)
	}

	defer func() {
		if err != nil || !opts.Auth {
			return
		}

		subject, e := auth.Auth(ctx)
		if e != nil {
			return
		}
		rcli.SAdd(ctx, fmt.Sprintf("%s%s", opts.Prefix, subject.GetID()), *ptr)
	}()

	if len(*ptr) > 0 {
		var tmp = make([]byte, 0, 25)
		tmp = append(tmp, opts.Prefix...)
		tmp = append(tmp, *ptr...)
		if rcli.TTL(ctx, utils.S(tmp)).Val() < 1 {
			// session is not generated by this server or expired
			*ptr = (*ptr)[:0]
		} else {
			// session is generated by this server
			*ptr = (*ptr)[:0]
			*ptr = append(*ptr, tmp...)
			s, err = *ptr, rcli.Expire(ctx, utils.S(*ptr), opts.MaxAge.Duration).Err()
			return
		}
	}

	*ptr = append(*ptr, opts.Prefix...)
	IDGenerator(ptr)
	request.SetSessionID()
	s, err = *ptr, rcli.EvalSha(ctx, createScriptHash, []string{utils.S(*ptr)}, maxage).Err()
	return
}

func Sessions(ctx context.Context) ([]Session, error) {
	subject, e := auth.Auth(ctx)
	if e != nil {
		return nil, e
	}

	a, e := rcli.EvalSha(ctx, sessionsScriptHash, []string{fmt.Sprintf("%s%s", opts.Prefix, subject.GetID())}).Result()
	if e != nil {
		return nil, e
	}

	var keys []Session
	for _, v := range a.([]interface{}) {
		keys = append(keys, utils.B(v.(string)))
	}
	return keys, nil
}
