package session

import (
	"context"
	"errors"
	"fmt"
	"github.com/zzztttkkk/sha/auth"
	"github.com/zzztttkkk/sha/captcha"
	"github.com/zzztttkkk/sha/jsonx"
	"github.com/zzztttkkk/sha/utils"
	"math/bits"
	"math/rand"
	"sync"
	"time"
)

type Options struct {
	Auth        bool               `toml:"auth" json:"auth"`
	Suffix      string             `json:"suffix" toml:"suffix"`
	MaxAge      utils.TomlDuration `json:"max_age" toml:"max-age"`
	ServerSeqID uint64             `json:"server_id" toml:"server-id"`

	Captcha struct {
		MaxAge utils.TomlDuration `json:"max_age" toml:"max-age"`
		Skip   bool               `json:"skip" toml:"skip"`
	} `json:"captcha" toml:"captcha"`

	CSRF struct {
		CookieName string             `json:"cookie_name" toml:"cookie-name"`
		HeaderName string             `json:"header_name" toml:"header-name"`
		MaxAge     utils.TomlDuration `json:"max_age" toml:"max-age"`
		Skip       bool               `json:"skip" toml:"skip"`
	} `json:"csrf" toml:"csrf"`
}

var opts Options

func init() {
	utils.MathRandSeed()
}

var IDGenerator = func(v *[]byte) {
	const encodeStd = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	writeUint := func(q uint64) {
		var r uint64
		for {
			q, r = bits.Div64(0, q, 64)
			*v = append(*v, encodeStd[r])
			if q == 0 {
				break
			}
		}
	}
	writeUint(opts.ServerSeqID)
	*v = append(*v, '.')
	writeUint(uint64(time.Now().UnixNano()))
	*v = append(*v, '.')
	for i := 0; i < 6; i++ {
		*v = append(*v, encodeStd[rand.Int()%64])
	}
}

var CRSFTokenGenerator = func(v []byte) {
	const encodeStd = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	for i := 0; i < len(v); i++ {
		v[i] = encodeStd[rand.Int()%64]
	}
}

var ImageCaptchaGenerator captcha.Generator
var AudioCaptchaGenerator captcha.Generator
var Marshal = jsonx.Marshal
var Unmarshal = jsonx.Unmarshal

var backend Backend
var once sync.Once
var DefaultOpts Options

func init() {
	DefaultOpts.MaxAge.Duration = time.Hour * 3
	DefaultOpts.Captcha.MaxAge.Duration = time.Minute * 5
	DefaultOpts.CSRF.CookieName = "csrf"
	DefaultOpts.CSRF.HeaderName = "X-CSRF"
	DefaultOpts.CSRF.MaxAge.Duration = time.Minute * 30
}

func Init(opt *Options, v Backend) {
	once.Do(func() {
		backend = v
		if opt == nil {
			opts = DefaultOpts
		} else {
			opts = *opt
			utils.Merge(&opts, DefaultOpts)
		}
	})
}

var ErrEmptySession = errors.New("sha.session: nil")

func New(ctx context.Context, request Request) (s Session, err error) {
	var ptr = request.GetSessionID()
	if ptr == nil || *ptr == nil {
		return nil, ErrEmptySession
	}

	defer func() {
		if err != nil || !opts.Auth {
			return
		}

		subject, e := auth.Auth(ctx)
		if e != nil {
			return
		}
		_ = backend.SessionSet(ctx, fmt.Sprintf(""), "", nil)
	}()

	if len(*ptr) > 0 {
		*ptr = append(*ptr, opts.Suffix...)
		if backend.TTLSession(ctx, utils.S(*ptr)) < 1 {
			// session is not generated by this server or expired
			*ptr = (*ptr)[:0]
		} else {
			// session is generated by this server
			s, err = *ptr, backend.ExpireSession(ctx, utils.S(*ptr), opts.MaxAge.Duration)
			return
		}
	}
	IDGenerator(ptr)
	request.SetSessionID()
	*ptr = append(*ptr, opts.Suffix...)
	s, err = *ptr, backend.NewSession(ctx, utils.S(*ptr), opts.MaxAge.Duration)
	return
}
